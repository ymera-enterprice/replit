# YMERA Enterprise Performance Testing & Integration Suite
# Comprehensive testing system for all YMERA components

import asyncio
import aiohttp
import time
import json
import statistics
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, asdict
from datetime import datetime
import concurrent.futures
import threading
import websockets
import hashlib

@dataclass
class TestResult:
    """Test result data structure"""
    test_name: str
    status: str  # PASSED, FAILED, WARNING, SLOW
    execution_time: float
    metrics: Dict[str, Any]
    errors: List[str]
    recommendations: List[str]
    timestamp: str = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now().isoformat()

@dataclass
class PerformanceBenchmark:
    """Performance benchmark thresholds"""
    api_response_time: float = 2.0  # seconds
    websocket_connection_time: float = 1.0  # seconds
    groq_inference_time: float = 3.0  # seconds
    pinecone_query_time: float = 1.5  # seconds
    concurrent_users: int = 100
    messages_per_second: int = 50
    memory_usage_mb: int = 512
    cpu_usage_percent: int = 80

class YMERAIntegratedTester:
    """Comprehensive testing suite for all YMERA components"""
    
    def __init__(self, base_url: str, websocket_url: str = None):
        self.base_url = base_url.rstrip('/')
        self.websocket_url = websocket_url or base_url.replace('http', 'ws')
        self.benchmark = PerformanceBenchmark()
        self.session = None
        self.test_results: List[TestResult] = []
        
        # Test configurations
        self.test_config = {
            "concurrent_users": 50,
            "test_duration": 30,  # seconds
            "sample_code": '''
def process_user_input(user_data):
    # Potential security vulnerability
    query = "SELECT * FROM users WHERE id = " + user_data["id"]
    result = database.execute(query)
    return result
            ''',
            "groq_api_key": "test_key",
            "pinecone_api_key": "test_key"
        }
    
    async def run_comprehensive_tests(self) -> Dict[str, Any]:
        """Run all integrated tests and return comprehensive report"""
        
        print("ðŸš€ YMERA Enterprise Platform - Comprehensive Testing Suite")
        print("=" * 60)
        print(f"Target Platform: {self.base_url}")
        print(f"Test Started: {datetime.now().isoformat()}")
        print("=" * 60)
        
        # Initialize HTTP session
        self.session = aiohttp.ClientSession()
        
        try:
            # Test categories with their respective tests
            test_categories = [
                ("ðŸ”§ Platform Health", [
                    ("Health Check", self._test_health_endpoint),
                    ("API Gateway", self._test_api_gateway),
                    ("Authentication", self._test_authentication_system)
                ]),
                ("ðŸ¤– AI Services", [
                    ("GROQ Integration", self._test_groq_integration),
                    ("Pinecone Vector DB", self._test_pinecone_integration),
                    ("Code Analysis", self._test_code_analysis_pipeline)
                ]),
                ("âš¡ WebSocket System", [
                    ("Connection Speed", self._test_websocket_connection),
                    ("Real-time Streaming", self._test_websocket_streaming),
                    ("Message Throughput", self._test_websocket_throughput)
                ]),
                ("ðŸ“Š Performance", [
                    ("Load Testing", self._test_load_performance),
                    ("Concurrent Users", self._test_concurrent_users),
                    ("Resource Usage", self._test_resource_usage)
                ]),
                ("ðŸ”„ Integration", [
                    ("End-to-End Workflow", self._test_e2e_workflow),
                    ("Data Flow", self._test_data_flow_integrity),
                    ("Error Handling", self._test_error_handling)
                ])
            ]
            
            # Execute test categories
            for category_name, tests in test_categories:
                print(f"\n{category_name}")
                print("-" * len(category_name))
                
                for test_name, test_func in tests:
                    print(f"  ðŸ“‹ {test_name}... ", end="", flush=True)
                    
                    start_time = time.time()
                    try:
                        result = await test_func()
                        result.test_name = test_name
                        result.execution_time = time.time() - start_time
                        
                        self.test_results.append(result)
                        
                        # Print result
                        status_icon = {
                            "PASSED": "âœ…",
                            "FAILED": "âŒ", 
                            "WARNING": "âš ï¸",
                            "SLOW": "ðŸŒ"
                        }.get(result.status, "â“")
                        
                        print(f"{status_icon} {result.status} ({result.execution_time:.2f}s)")
                        
                        # Show key metrics
                        if result.metrics:
                            for key, value in result.metrics.items():
                                if key in ['response_time', 'throughput', 'success_rate']:
                                    print(f"      {key}: {value}")
                        
                        # Show errors if any
                        if result.errors:
                            for error in result.errors[:2]:  # Show first 2 errors
                                print(f"      âš ï¸ {error}")
                    
                    except Exception as e:
                        execution_time = time.time() - start_time
                        error_result = TestResult(
                            test_name=test_name,
                            status="FAILED",
                            execution_time=execution_time,
                            metrics={},
                            errors=[str(e)],
                            recommendations=[f"Fix {test_name} implementation"]
                        )
                        self.test_results.append(error_result)
                        print(f"âŒ FAILED ({execution_time:.2f}s)")
                        print(f"      âš ï¸ {str(e)}")
            
            # Generate comprehensive report
            report = self._generate_comprehensive_report()
            
            print(f"\nðŸ“Š COMPREHENSIVE TEST REPORT")
            print("=" * 40)
            print(f"Total Tests: {report['total_tests']}")
            print(f"Passed: {report['passed']} ({report['pass_rate']:.1f}%)")
            print(f"Failed: {report['failed']}")
            print(f"Warnings: {report['warnings']}")
            print(f"Average Response Time: {report['avg_response_time']:.3f}s")
            print(f"Platform Health: {report['overall_health']}")
            
            return report
            
        finally:
            if self.session:
                await self.session.close()
    
    # Platform Health Tests
    async def _test_health_endpoint(self) -> TestResult:
        """Test platform health endpoint"""
        
        try:
            start_time = time.time()
            async with self.session.get(f"{self.base_url}/health") as response:
                response_time = time.time() - start_time
                
                if response.status == 200:
                    status = "PASSED" if response_time < self.benchmark.api_response_time else "SLOW"
                    return TestResult(
                        test_name="Health Check",
                        status=status,
                        execution_time=response_time,
                        metrics={
                            "response_time": f"{response_time:.3f}s",
                            "status_code": response.status,
                            "endpoint": "/health"
                        },
                        errors=[],
                        recommendations=["Optimize response time"] if status == "SLOW" else []
                    )
                else:
                    return TestResult(
                        test_name="Health Check",
                        status="FAILED",
                        execution_time=response_time,
                        metrics={"status_code": response.status},
                        errors=[f"Unexpected status code: {response.status}"],
                        recommendations=["Fix health endpoint implementation"]
                    )
                    
        except Exception as e:
            return TestResult(
                test_name="Health Check",
                status="FAILED",
                execution_time=0.0,
                metrics={},
                errors=[str(e)],
                recommendations=["Ensure server is running", "Check network connectivity"]
            )
    
    async def _test_api_gateway(self) -> TestResult:
        """Test API gateway functionality"""
        
        endpoints_to_test = [
            "/api/deployment/status",
            "/api/terminal/lines",
            "/ws-stats"
        ]
        
        successful_endpoints = 0
        total_response_time = 0.0
        errors = []
        
        for endpoint in endpoints_to_test:
            try:
                start_time = time.time()
                async with self.session.get(f"{self.base_url}{endpoint}") as response:
                    response_time = time.time() - start_time
                    total_response_time += response_time
                    
                    if response.status in [200, 404]:  # 404 acceptable for optional endpoints
                        successful_endpoints += 1
                    else:
                        errors.append(f"{endpoint}: HTTP {response.status}")
                        
            except Exception as e:
                errors.append(f"{endpoint}: {str(e)}")
        
        success_rate = (successful_endpoints / len(endpoints_to_test)) * 100
        avg_response_time = total_response_time / len(endpoints_to_test)
        
        if success_rate >= 80:
            status = "PASSED" if avg_response_time < self.benchmark.api_response_time else "SLOW"
        elif success_rate >= 50:
            status = "WARNING"
        else:
            status = "FAILED"
        
        return TestResult(
            test_name="API Gateway",
            status=status,
            execution_time=total_response_time,
            metrics={
                "success_rate": f"{success_rate:.1f}%",
                "avg_response_time": f"{avg_response_time:.3f}s",
                "endpoints_tested": len(endpoints_to_test),
                "successful_endpoints": successful_endpoints
            },
            errors=errors,
            recommendations=["Fix failed endpoints", "Optimize response times"] if errors else []
        )
    
    async def _test_authentication_system(self) -> TestResult:
        """Test authentication system"""
        
        auth_tests = [
            ("POST", "/auth/login", {"username": "test", "password": "test"}),
            ("GET", "/auth/profile", {}),
            ("POST", "/auth/refresh", {})
        ]
        
        auth_results = []
        errors = []
        
        for method, endpoint, data in auth_tests:
            try:
                start_time = time.time()
                
                if method == "POST":
                    async with self.session.post(f"{self.base_url}{endpoint}", json=data) as response:
                        response_time = time.time() - start_time
                        auth_results.append((endpoint, response.status, response_time))
                else:
                    async with self.session.get(f"{self.base_url}{endpoint}") as response:
                        response_time = time.time() - start_time
                        auth_results.append((endpoint, response.status, response_time))
                        
            except Exception as e:
                errors.append(f"{endpoint}: {str(e)}")
        
        # Evaluate auth system health
        working_endpoints = sum(1 for _, status, _ in auth_results if status in [200, 401, 404])
        total_time = sum(time for _, _, time in auth_results)
        
        if working_endpoints >= len(auth_tests) * 0.8:
            status = "PASSED"
        elif working_endpoints >= len(auth_tests) * 0.5:
            status = "WARNING"
        else:
            status = "FAILED"
        
        return TestResult(
            test_name="Authentication System",
            status=status,
            execution_time=total_time,
            metrics={
                "working_endpoints": f"{working_endpoints}/{len(auth_tests)}",
                "total_response_time": f"{total_time:.3f}s",
                "avg_response_time": f"{total_time/len(auth_tests):.3f}s"
            },
            errors=errors,
            recommendations=["Implement missing auth endpoints"] if status != "PASSED" else []
        )
    
    # AI Services Tests
    async def _test_groq_integration(self) -> TestResult:
        """Test GROQ API integration"""
        
        # Simulate GROQ API test
        start_time = time.time()
        
        try:
            # Mock GROQ API call
            await asyncio.sleep(0.5)  # Simulate API latency
            
    async def _test_groq_integration(self) -> TestResult:
        """Test GROQ API integration"""
        
        # Simulate GROQ API test
        start_time = time.time()
        
        try:
            # Mock GROQ API call
            await asyncio.sleep(0.5)  # Simulate API latency
            
            # Simulate successful response
            response_time = time.time() - start_time
            
            # Test code analysis with GROQ
            test_analyses = [
                "security_scan",
                "code_quality",
                "performance_analysis"
            ]
            
            successful_analyses = 0
            total_inference_time = 0.0
            
            for analysis_type in test_analyses:
                analysis_start = time.time()
                # Simulate GROQ inference
                await asyncio.sleep(0.3)
                inference_time = time.time() - analysis_start
                total_inference_time += inference_time
                
                if inference_time < self.benchmark.groq_inference_time:
                    successful_analyses += 1
            
            success_rate = (successful_analyses / len(test_analyses)) * 100
            avg_inference_time = total_inference_time / len(test_analyses)
            
            if success_rate >= 90 and avg_inference_time < self.benchmark.groq_inference_time:
                status = "PASSED"
            elif success_rate >= 70:
                status = "WARNING"
            else:
                status = "FAILED"
            
            return TestResult(
                test_name="GROQ Integration",
                status=status,
                execution_time=response_time + total_inference_time,
                metrics={
                    "success_rate": f"{success_rate:.1f}%",
                    "avg_inference_time": f"{avg_inference_time:.3f}s",
                    "analyses_completed": f"{successful_analyses}/{len(test_analyses)}",
                    "total_time": f"{total_inference_time:.3f}s"
                },
                errors=[],
                recommendations=["Optimize GROQ queries", "Add caching layer"] if status != "PASSED" else []
            )
            
        except Exception as e:
            return TestResult(
                test_name="GROQ Integration",
                status="FAILED",
                execution_time=time.time() - start_time,
                metrics={},
                errors=[str(e)],
                recommendations=["Configure GROQ API key", "Check network connectivity"]
            )
    
    async def _test_pinecone_integration(self) -> TestResult:
        """Test Pinecone vector database integration"""
        
        start_time = time.time()
        
        try:
            # Simulate Pinecone operations
            operations = [
                ("index_creation", 1.0),
                ("vector_upsert", 0.5),
                ("similarity_search", 0.3),
                ("metadata_query", 0.4)
            ]
            
            successful_operations = 0
            total_query_time = 0.0
            errors = []
            
            for operation, expected_time in operations:
                operation_start = time.time()
                
                try:
                    # Simulate operation
                    await asyncio.sleep(expected_time * 0.1)  # Scaled down for testing
                    operation_time = time.time() - operation_start
                    total_query_time += operation_time
                    
                    if operation_time < self.benchmark.pinecone_query_time:
                        successful_operations += 1
                    else:
                        errors.append(f"{operation} took {operation_time:.3f}s (expected < {self.benchmark.pinecone_query_time}s)")
                        
                except Exception as e:
                    errors.append(f"{operation}: {str(e)}")
            
            success_rate = (successful_operations / len(operations)) * 100
            avg_query_time = total_query_time / len(operations)
            
            if success_rate >= 90:
                status = "PASSED"
            elif success_rate >= 70:
                status = "WARNING"
            else:
                status = "FAILED"
            
            return TestResult(
                test_name="Pinecone Integration",
                status=status,
                execution_time=time.time() - start_time,
                metrics={
                    "success_rate": f"{success_rate:.1f}%",
                    "avg_query_time": f"{avg_query_time:.3f}s",
                    "operations_completed": f"{successful_operations}/{len(operations)}",
                    "total_query_time": f"{total_query_time:.3f}s"
                },
                errors=errors,
                recommendations=["Configure Pinecone API key", "Optimize vector operations"] if errors else []
            )
            
        except Exception as e:
            return TestResult(
                test_name="Pinecone Integration",
                status="FAILED",
                execution_time=time.time() - start_time,
                metrics={},
                errors=[str(e)],
                recommendations=["Setup Pinecone index", "Check API configuration"]
            )
    
    async def _test_code_analysis_pipeline(self) -> TestResult:
        """Test end-to-end code analysis pipeline"""
        
        start_time = time.time()
        sample_code = self.test_config["sample_code"]
        
        try:
            # Test complete analysis pipeline
            pipeline_stages = [
                ("syntax_validation", 0.1),
                ("security_analysis", 0.8),
                ("quality_assessment", 0.6),
                ("vector_similarity", 0.4),
                ("recommendation_generation", 0.3)
            ]
            
            stage_results = {}
            total_pipeline_time = 0.0
            
            for stage, expected_time in pipeline_stages:
                stage_start = time.time()
                
                # Simulate stage processing
                await asyncio.sleep(expected_time * 0.1)
                stage_time = time.time() - stage_start
                total_pipeline_time += stage_time
                
                # Simulate stage results
                stage_results[stage] = {
                    "processing_time": stage_time,
                    "success": True,
                    "findings": f"Mock findings for {stage}"
                }
            
            # Evaluate pipeline performance
            if total_pipeline_time < 5.0:  # Target: complete analysis in 5 seconds
                status = "PASSED"
            elif total_pipeline_time < 8.0:
                status = "WARNING"
            else:
                status = "SLOW"
            
            return TestResult(
                test_name="Code Analysis Pipeline",
                status=status,
                execution_time=time.time() - start_time,
                metrics={
                    "total_pipeline_time": f"{total_pipeline_time:.3f}s",
                    "stages_completed": f"{len(stage_results)}/{len(pipeline_stages)}",
                    "avg_stage_time": f"{total_pipeline_time/len(pipeline_stages):.3f}s",
                    "code_length": len(sample_code)
                },
                errors=[],
                recommendations=["Optimize slow stages", "Add parallel processing"] if status != "PASSED" else []
            )
            
        except Exception as e:
            return TestResult(
                test_name="Code Analysis Pipeline",
                status="FAILED",
                execution_time=time.time() - start_time,
                metrics={},
                errors=[str(e)],
                recommendations=["Fix pipeline implementation", "Check AI service connections"]
            )
    
    # WebSocket Tests
    async def _test_websocket_connection(self) -> TestResult:
        """Test WebSocket connection establishment"""
        
        connection_attempts = 10
        successful_connections = 0
        connection_times = []
        errors = []
        
        for i in range(connection_attempts):
            start_time = time.time()
            
            try:
                # Simulate WebSocket connection
                await asyncio.sleep(0.1)  # Simulate connection time
                connection_time = time.time() - start_time
                connection_times.append(connection_time)
                
                if connection_time < self.benchmark.websocket_connection_time:
                    successful_connections += 1
                    
            except Exception as e:
                errors.append(f"Connection {i+1}: {str(e)}")
        
        success_rate = (successful_connections / connection_attempts) * 100
        avg_connection_time = statistics.mean(connection_times) if connection_times else 0
        
        if success_rate >= 90 and avg_connection_time < self.benchmark.websocket_connection_time:
            status = "PASSED"
        elif success_rate >= 70:
            status = "WARNING"
        else:
            status = "FAILED"
        
        return TestResult(
            test_name="WebSocket Connection",
            status=status,
            execution_time=sum(connection_times),
            metrics={
                "success_rate": f"{success_rate:.1f}%",
                "avg_connection_time": f"{avg_connection_time:.3f}s",
                "successful_connections": f"{successful_connections}/{connection_attempts}",
                "min_time": f"{min(connection_times):.3f}s" if connection_times else "N/A",
                "max_time": f"{max(connection_times):.3f}s" if connection_times else "N/A"
            },
            errors=errors,
            recommendations=["Optimize WebSocket handshake", "Check server configuration"] if errors else []
        )
    
    async def _test_websocket_streaming(self) -> TestResult:
        """Test WebSocket real-time streaming"""
        
        start_time = time.time()
        
        try:
            # Simulate streaming test
            stream_duration = 5.0  # seconds
            expected_messages = 50
            messages_received = 0
            latencies = []
            
            # Simulate message streaming
            message_start = time.time()
            while time.time() - message_start < stream_duration:
                # Simulate message reception
                message_time = time.time()
                await asyncio.sleep(0.1)
                latency = time.time() - message_time
                latencies.append(latency)
                messages_received += 1
            
            actual_duration = time.time() - message_start
            messages_per_second = messages_received / actual_duration
            avg_latency = statistics.mean(latencies) if latencies else 0
            
            if messages_received >= expected_messages and messages_per_second >= self.benchmark.messages_per_second:
                status = "PASSED"
            elif messages_received >= expected_messages * 0.8:
                status = "WARNING"
            else:
                status = "FAILED"
            
            return TestResult(
                test_name="WebSocket Streaming",
                status=status,
                execution_time=time.time() - start_time,
                metrics={
                    "messages_received": messages_received,
                    "expected_messages": expected_messages,
                    "messages_per_second": f"{messages_per_second:.1f}",
                    "avg_latency": f"{avg_latency*1000:.1f}ms",
                    "stream_duration": f"{actual_duration:.1f}s"
                },
                errors=[],
                recommendations=["Optimize message delivery", "Reduce latency"] if status != "PASSED" else []
            )
            
        except Exception as e:
            return TestResult(
                test_name="WebSocket Streaming",
                status="FAILED",
                execution_time=time.time() - start_time,
                metrics={},
                errors=[str(e)],
                recommendations=["Fix WebSocket streaming implementation"]
            )
    
    async def _test_websocket_throughput(self) -> TestResult:
        """Test WebSocket message throughput"""
        
        start_time = time.time()
        
        try:
            # Simulate high-throughput message testing
            message_count = 1000
            batch_size = 50
            successful_messages = 0
            failed_messages = 0
            
            # Process messages in batches
            for batch_start in range(0, message_count, batch_size):
                batch_end = min(batch_start + batch_size, message_count)
                batch_messages = batch_end - batch_start
                
                # Simulate batch processing
                batch_time = time.time()
                await asyncio.sleep(0.1)  # Simulate batch processing time
                
                # Simulate success/failure
                successful_messages += batch_messages
            
            total_time = time.time() - start_time
            throughput = successful_messages / total_time
            
            if throughput >= self.benchmark.messages_per_second:
                status = "PASSED"
            elif throughput >= self.benchmark.messages_per_second * 0.7:
                status = "WARNING"
            else:
                status = "SLOW"
            
            return TestResult(
                test_name="WebSocket Throughput",
                status=status,
                execution_time=total_time,
                metrics={
                    "messages_processed": successful_messages,
                    "failed_messages": failed_messages,
                    "throughput": f"{throughput:.1f} msg/s",
                    "target_throughput": f"{self.benchmark.messages_per_second} msg/s",
                    "success_rate": f"{(successful_messages/message_count)*100:.1f}%"
                },
                errors=[],
                recommendations=["Optimize message processing", "Implement message queuing"] if status != "PASSED" else []
            )
            
        except Exception as e:
            return TestResult(
                test_name="WebSocket Throughput",
                status="FAILED",
                execution_time=time.time() - start_time,
                metrics={},
                errors=[str(e)],
                recommendations=["Fix throughput bottlenecks"]
            )
    
    # Performance Tests
    async def _test_load_performance(self) -> TestResult:
        """Test system performance under load"""
        
        start_time = time.time()
        
        try:
            # Simulate load testing
            concurrent_requests = 100
            request_duration = 10.0  # seconds
            
            async def simulate_user_session():
                session_start = time.time()
                requests_made = 0
                
                while time.time() - session_start < request_duration:
                    # Simulate API request
                    await asyncio.sleep(0.1)
                    requests_made += 1
                
                return requests_made
            
            # Create concurrent user sessions
            tasks = [simulate_user_session() for _ in range(concurrent_requests)]
            results = await asyncio.gather(*tasks)
            
            total_requests = sum(results)
            avg_requests_per_user = statistics.mean(results)
            requests_per_second = total_requests / request_duration
            
            # Evaluate performance
            if requests_per_second >= 100:  # Target: 100 RPS
                status = "PASSED"
            elif requests_per_second >= 50:
                status = "WARNING"
            else:
                status = "SLOW"
            
            return TestResult(
                test_name="Load Performance",
                status=status,
                execution_time=time.time() - start_time,
                metrics={
                    "concurrent_users": concurrent_requests,
                    "total_requests": total_requests,
                    "requests_per_second": f"{requests_per_second:.1f}",
                    "avg_requests_per_user": f"{avg_requests_per_user:.1f}",
                    "test_duration": f"{request_duration:.1f}s"
                },
                errors=[],
                recommendations=["Scale server resources", "Optimize database queries"] if status != "PASSED" else []
            )
            
        except Exception as e:
            return TestResult(
                test_name="Load Performance",
                status="FAILED",
                execution_time=time.time() - start_time,
                metrics={},
                errors=[str(e)],
                recommendations=["Fix load testing implementation"]
            )
    
    async def _test_concurrent_users(self) -> TestResult:
        """Test concurrent user handling"""
        
        start_time = time.time()
        
        try:
            # Simulate concurrent users
            user_count = self.test_config["concurrent_users"]
            session_duration = 5.0  # seconds
            
            async def simulate_user():
                user_start = time.time()
                actions_completed = 0
                
                while time.time() - user_start < session_duration:
                    # Simulate user actions
                    await asyncio.sleep(0.2)
                    actions_completed += 1
                
                return actions_completed
            
            # Create concurrent users
            user_tasks = [simulate_user() for _ in range(user_count)]
            user_results = await asyncio.gather(*user_tasks)
            
            successful_users = len([r for r in user_results if r > 0])
            total_actions = sum(user_results)
            success_rate = (successful_users / user_count) * 100
            
            if success_rate >= 95:
                status = "PASSED"
            elif success_rate >= 80:
                status = "WARNING"
            else:
                status = "FAILED"
            
            return TestResult(
                test_name="Concurrent Users",
                status=status,
                execution_time=time.time() - start_time,
                metrics={
                    "concurrent_users": user_count,
                    "successful_users": successful_users,
                    "success_rate": f"{success_rate:.1f}%",
                    "total_actions": total_actions,
                    "avg_actions_per_user": f"{total_actions/user_count:.1f}"
                },
                errors=[],
                recommendations=["Increase server capacity", "Optimize connection pooling"] if status != "PASSED" else []
            )
            
        except Exception as e:
            return TestResult(
                test_name="Concurrent Users",
                status="FAILED",
                execution_time=time.time() - start_time,
                metrics={},
                errors=[str(e)],
                recommendations=["Fix concurrent user handling"]
            )
    
    async def _test_resource_usage(self) -> TestResult:
        """Test system resource usage"""
        
        start_time = time.time()
        
        try:
            # Simulate resource monitoring
            monitoring_duration = 10.0  # seconds
            samples = []
            
            monitor_start = time.time()
            while time.time() - monitor_start < monitoring_duration:
                # Simulate resource measurement
                cpu_usage = min(100, max(0, 45 + (time.time() % 10) * 2))  # Simulate 45-65% CPU
                memory_usage = min(512, max(100, 200 + (time.time() % 5) * 20))  # Simulate 200-300 MB
                
                samples.append({
                    "cpu_percent": cpu_usage,
                    "memory_mb": memory_usage,
                    "timestamp": time.time()
                })
                
                await asyncio.sleep(0.5)
            
            # Calculate resource statistics
            avg_cpu = statistics.mean([s["cpu_percent"] for s in samples])
            max_cpu = max([s["cpu_percent"] for s in samples])
            avg_memory = statistics.mean([s["memory_mb"] for s in samples])
            max_memory = max([s["memory_mb"] for s in samples])
            
            # Evaluate resource usage
            if max_cpu < self.benchmark.cpu_usage_percent and max_memory < self.benchmark.memory_usage_mb:
                status = "PASSED"
            elif avg_cpu < self.benchmark.cpu_usage_percent and avg_memory < self.benchmark.memory_usage_mb:
                status = "WARNING"
            else:
                status = "FAILED"
            
            return TestResult(
                test_name="Resource Usage",
                status=status,
                execution_time=time.time() - start_time,
                metrics={
                    "avg_cpu_percent": f"{avg_cpu:.1f}%",
                    "max_cpu_percent": f"{max_cpu:.1f}%",
                    "avg_memory_mb": f"{avg_memory:.1f} MB",
                    "max_memory_mb": f"{max_memory:.1f} MB",
                    "samples_collected": len(samples)
                },
                errors=[],
                recommendations=["Optimize resource usage", "Consider scaling up"] if status == "FAILED" else []
            )
            
        except Exception as e:
            return TestResult(
                test_name="Resource Usage",
                status="FAILED",
                execution_time=time.time() - start_time,
                metrics={},
                errors=[str(e)],
                recommendations=["Implement resource monitoring"]
            )
    
    # Integration Tests
    async def _test_e2e_workflow(self) -> TestResult:
        """Test end-to-end workflow integration"""
        
        start_time = time.time()
        
        try:
            # Simulate complete user workflow
            workflow_steps = [
                ("user_authentication", 0.5),
                ("project_creation", 0.8),
                ("code_upload", 1.0),
                ("ai_analysis_request", 0.3),
                ("groq_processing", 2.0),
                ("pinecone_search", 0.7),
                ("results_compilation", 0.5),
                ("websocket_delivery", 0.2)
            ]
            
            completed_steps = 0
            total_workflow_time = 0.0
            step_results = {}
            
            for step_name, expected_time in workflow_steps:
                step_start = time.time()
                
                # Simulate step execution
                await asyncio.sleep(expected_time * 0.1)  # Scaled down for testing
                step_time = time.time() - step_start
                total_workflow_time += step_time
                
                step_results[step_name] = {
                    "execution_time": step_time,
                    "success": True
                }
                completed_steps += 1
            
            success_rate = (completed_steps / len(workflow_steps)) * 100
            
            if success_rate == 100 and total_workflow_time < 10.0:  # Target: 10 seconds end-to-end
                status = "PASSED"
            elif success_rate >= 90:
                status = "WARNING"
            else:
                status = "FAILED"
            
            return TestResult(
                test_name="End-to-End Workflow",
                status=status,
                execution_time=time.time() - start_time,
                metrics={
                    "workflow_steps": len(workflow_steps),
                    "completed_steps": completed_steps,
                    "success_rate": f"{success_rate:.1f}%",
                    "total_workflow_time": f"{total_workflow_time:.3f}s",
                    "avg_step_time": f"{total_workflow_time/len(workflow_steps):.3f}s"
                },
                errors=[],
                recommendations=["Optimize slow workflow steps"] if status != "PASSED" else []
            )
            
        except Exception as e:
            return TestResult(
                test_name="End-to-End Workflow",
                status="FAILED",
                execution_time=time.time() - start_time,
                metrics={},
                errors=[str(e)],
                recommendations=["Fix workflow integration issues"]
            )
    
    async def _test_data_flow_integrity(self) -> TestResult:
        """Test data flow integrity across components"""
        
        start_time = time.time()
        
        try:
            # Simulate data flow testing
            data_checkpoints = [
                ("input_validation", "user_data"),
                ("authentication_token", "jwt_token"),
                ("code_preprocessing", "sanitized_code"),
                ("ai_analysis", "analysis_results"),
                ("vector_storage", "embeddings"),
                ("result_aggregation", "final_report")
            ]
            
            data_integrity_score = 0
            integrity_checks = len(data_checkpoints)
            
            for checkpoint, data_type in data_checkpoints:
                # Simulate data integrity check
                await asyncio.sleep(0.1)
                
                # Simulate data validation
                integrity_check = True  # Mock validation result
                
                if integrity_check:
                    data_integrity_score += 1
            
            integrity_percentage = (data_integrity_score / integrity_checks) * 100
            
            if integrity_percentage == 100:
                status = "PASSED"
            elif integrity_percentage >= 90:
                status = "WARNING"
            else:
                status = "FAILED"
            
            return TestResult(
                test_name="Data Flow Integrity",
                status=status,
                execution_time=time.time() - start_time,
                metrics={
                    "integrity_score": f"{data_integrity_score}/{integrity_checks}",
                    "integrity_percentage": f"{integrity_percentage:.1f}%",
                    "checkpoints_tested": len(data_checkpoints)
                },
                errors=[],
                recommendations=["Fix data validation issues"] if status != "PASSED" else []
            )
            
        except Exception as e:
            return TestResult(
                test_name="Data Flow Integrity",
                status="FAILED",
                execution_time=time.time() - start_time,
                metrics={},
                errors=[str(e)],
                recommendations=["Implement data integrity checks"]
            )
    
    async def _test_error_handling(self) -> TestResult:
        """Test system error handling capabilities"""
        
        start_time = time.time()
        
        try:
            # Test various error scenarios
            error_scenarios = [
                ("invalid_json_input", "malformed request"),
                ("authentication_failure", "invalid credentials"),
                ("rate_limit_exceeded", "too many requests"),
                ("ai_service_timeout", "service unavailable"),
                ("database_connection_error", "connection failed"),
                ("websocket_disconnection", "connection lost")
            ]
            
            handled_errors = 0
            error_responses = {}
            
            for scenario, description in error_scenarios:
                # Simulate error scenario
                await asyncio.sleep(0.1)
                
                # Simulate error handling
                error_handled = True  # Mock error handling result
                recovery_time = 0.2  # Mock recovery time
                
                error_responses[scenario] = {
                    "handled": error_handled,
                    "recovery_time": recovery_time,
                    "description": description
                }
                
                if error_handled:
                    handled_errors += 1
            
            error_handling_rate = (handled_errors / len(error_scenarios)) * 100
            
            if error_handling_rate == 100:
                status = "PASSED"
            elif error_handling_rate >= 80:
                status = "WARNING"
            else:
                status = "FAILED"
            
            return TestResult(
                test_name="Error Handling",
                status=status,
                execution_time=time.time() - start_time,
                metrics={
                    "scenarios_tested": len(error_scenarios),
                    "errors_handled": handled_errors,
                    "error_handling_rate": f"{error_handling_rate:.1f}%",
                    "avg_recovery_time": f"{sum(r['recovery_time'] for r in error_responses.values())/len(error_responses):.3f}s"
                },
                errors=[],
                recommendations=["Improve error handling coverage"] if status != "PASSED" else []
            )
            
        except Exception as e:
            return TestResult(
                test_name="Error Handling",
                status="FAILED",
                execution_time=time.time() - start_time,
                metrics={},
                errors=[str(e)],
                recommendations=["Implement comprehensive error handling"]
            )
    
    def _generate_comprehensive_report(self) -> Dict[str, Any]:
        """Generate comprehensive test report"""
        
        if not self.test_results:
            return {"error": "No test results available"}
        
        # Calculate summary statistics
        total_tests = len(self.test_results)
        passed = len([r for r in self.test_results if r.status == "PASSED"])
        failed = len([r for r in self.test_results if r.status == "FAILED"])
        warnings = len([r for r in self.test_results if r.status in ["WARNING", "SLOW"]])
        
        pass_rate = (passed / total_tests) * 100
        avg_response_time = statistics.mean([r.execution_time for r in self.test_results])
        
        # Determine overall health
        if pass_rate >= 90:
            overall_health = "EXCELLENT"
        elif pass_rate >= 80:
            overall_health = "GOOD"
        elif pass_rate >= 70:
            overall_health = "FAIR"
        else:
            overall_health = "POOR"
        
        # Collect recommendations
        all_recommendations = []
        for result in self.test_results:
            all_recommendations.extend(result.recommendations)
        
        # Get performance bottlenecks
        slow_tests = [r for r in self.test_results if r.execution_time > 3.0]
        
        return {
            "test_execution_time": datetime.now().isoformat(),
            "total_tests": total_tests,
            "passed": passed,
            "failed": failed,
            "warnings": warnings,
            "pass_rate": pass_rate,
            "overall_health": overall_health,
            "avg_response_time": avg_response_time,
            "performance_bottlenecks": [
                {"test": t.test_name, "time": t.execution_time} 
                for t in slow_tests
            ],
            "critical_issues": [
                {"test": r.test_name, "errors": r.errors}
                for r in self.test_results if r.status == "FAILED"
            ],
            "recommendations": list(set(all_recommendations)),
            "detailed_results": [asdict(result) for result in self.test_results]
        }

# Command-line interface for testing
async def run_ymera_tests(base_url: str, websocket_url: str = None):
    """Run YMERA comprehensive tests from command line"""
    
    tester = YMERAIntegratedTester(base_url, websocket_url)
    report = await tester.run_comprehensive_tests()
    
    # Save report to file
    report_filename = f"ymera_test_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    with open(report_filename, 'w') as f:
        json.dump(report, f, indent=2, default=str)
    
    print(f"\nðŸ“„ Detailed report saved to: {report_filename}")
    return report

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python ymera_performance_test.py <base_url> [websocket_url]")
        sys.exit(1)
    
    base_url = sys.argv[1]
    websocket_url = sys.argv[2] if len(sys.argv) > 2 else None
    
    asyncio.run(run_ymera_tests(base_url, websocket_url))